import{i as k,g,f as h,h as v}from"./scheduler.BWOwpdHh.js";import{g as x,f as o,h as w,t as A}from"./index.MrXRJrN0.js";function _(c,t){const r=t.token={};function e(s,u,b,p){if(t.token!==r)return;t.resolved=p;let n=t.ctx;b!==void 0&&(n=n.slice(),n[b]=p);const l=s&&(t.current=s)(n);let m=!1;t.block&&(t.blocks?t.blocks.forEach((d,a)=>{a!==u&&d&&(x(),o(d,1,1,()=>{t.blocks[a]===d&&(t.blocks[a]=null)}),w())}):t.block.d(1),l.c(),A(l,1),l.m(t.mount(),t.anchor),m=!0),t.block=l,t.blocks&&(t.blocks[u]=l),m&&v()}if(k(c)){const s=g();if(c.then(u=>{h(s),e(t.then,1,t.value,u),h(null)},u=>{if(h(s),e(t.catch,2,t.error,u),h(null),!t.hasCatch)throw u}),t.current!==t.pending)return e(t.pending,0),!0}else{if(t.current!==t.then)return e(t.then,1,t.value,c),!0;t.resolved=c}}function j(c,t,r){const e=t.slice(),{resolved:s}=c;c.current===c.then&&(e[c.value]=s),c.current===c.catch&&(e[c.error]=s),c.block.p(e,r)}function q(c){return(c==null?void 0:c.length)!==void 0?c:Array.from(c)}export{q as e,_ as h,j as u};
